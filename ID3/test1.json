{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Decision Tree Classification\n",
    "## ID3 Algorithm\n",
    "\n",
    "> Name: Debatreya Das <br>\n",
    "> Roll No.: 12212070 <br>\n",
    "> CS A4 <br>\n",
    "> Lab 10 <br>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Importing Necessary Libraries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Loading the Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Outlook</th>\n",
       "      <th>Temperature</th>\n",
       "      <th>Humidity</th>\n",
       "      <th>Wind</th>\n",
       "      <th>Answer</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>sunny</td>\n",
       "      <td>hot</td>\n",
       "      <td>high</td>\n",
       "      <td>weak</td>\n",
       "      <td>no</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>sunny</td>\n",
       "      <td>hot</td>\n",
       "      <td>high</td>\n",
       "      <td>strong</td>\n",
       "      <td>no</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>overcast</td>\n",
       "      <td>hot</td>\n",
       "      <td>high</td>\n",
       "      <td>weak</td>\n",
       "      <td>yes</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>rain</td>\n",
       "      <td>mild</td>\n",
       "      <td>high</td>\n",
       "      <td>weak</td>\n",
       "      <td>yes</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>rain</td>\n",
       "      <td>cool</td>\n",
       "      <td>normal</td>\n",
       "      <td>weak</td>\n",
       "      <td>yes</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>5</th>\n",
       "      <td>rain</td>\n",
       "      <td>cool</td>\n",
       "      <td>normal</td>\n",
       "      <td>strong</td>\n",
       "      <td>no</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>6</th>\n",
       "      <td>overcast</td>\n",
       "      <td>cool</td>\n",
       "      <td>normal</td>\n",
       "      <td>strong</td>\n",
       "      <td>yes</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>7</th>\n",
       "      <td>sunny</td>\n",
       "      <td>mild</td>\n",
       "      <td>high</td>\n",
       "      <td>weak</td>\n",
       "      <td>no</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>8</th>\n",
       "      <td>sunny</td>\n",
       "      <td>cool</td>\n",
       "      <td>normal</td>\n",
       "      <td>weak</td>\n",
       "      <td>yes</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>9</th>\n",
       "      <td>rain</td>\n",
       "      <td>mild</td>\n",
       "      <td>normal</td>\n",
       "      <td>weak</td>\n",
       "      <td>yes</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10</th>\n",
       "      <td>sunny</td>\n",
       "      <td>mild</td>\n",
       "      <td>normal</td>\n",
       "      <td>strong</td>\n",
       "      <td>yes</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>11</th>\n",
       "      <td>overcast</td>\n",
       "      <td>mild</td>\n",
       "      <td>high</td>\n",
       "      <td>strong</td>\n",
       "      <td>yes</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>12</th>\n",
       "      <td>overcast</td>\n",
       "      <td>hot</td>\n",
       "      <td>normal</td>\n",
       "      <td>weak</td>\n",
       "      <td>yes</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>13</th>\n",
       "      <td>rain</td>\n",
       "      <td>mild</td>\n",
       "      <td>high</td>\n",
       "      <td>strong</td>\n",
       "      <td>no</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "     Outlook Temperature Humidity    Wind Answer\n",
       "0      sunny         hot     high    weak     no\n",
       "1      sunny         hot     high  strong     no\n",
       "2   overcast         hot     high    weak    yes\n",
       "3       rain        mild     high    weak    yes\n",
       "4       rain        cool   normal    weak    yes\n",
       "5       rain        cool   normal  strong     no\n",
       "6   overcast        cool   normal  strong    yes\n",
       "7      sunny        mild     high    weak     no\n",
       "8      sunny        cool   normal    weak    yes\n",
       "9       rain        mild   normal    weak    yes\n",
       "10     sunny        mild   normal  strong    yes\n",
       "11  overcast        mild     high  strong    yes\n",
       "12  overcast         hot   normal    weak    yes\n",
       "13      rain        mild     high  strong     no"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df = pd.read_csv('./id3.csv')\n",
    "\n",
    "df"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### HELPER FUNCTIONS"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 1. Entropy(S)\n",
    "Considering the last column as the target. Calculate the Entropy of the Example Set S"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "def Entropy(data):\n",
    "    # Count positive and negative examples in the target column\n",
    "    target = data.iloc[:, -1]  # Assuming target is the last column\n",
    "    values, counts = np.unique(target, return_counts=True)\n",
    "    probabilities = counts / counts.sum()\n",
    "    \n",
    "    # Calculate entropy\n",
    "    entropy = -np.sum(probabilities * np.log2(probabilities))\n",
    "    return entropy\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 2. Gain(S, A)\n",
    "Calcualte the Information gain when feature A is selected in dataset S"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "def Gain(data, feature):\n",
    "    # Calculate the entropy of the whole dataset\n",
    "    total_entropy = Entropy(data)\n",
    "    \n",
    "    # Get the values and the counts of the split for the given feature\n",
    "    values, counts = np.unique(data[feature], return_counts=True)\n",
    "    \n",
    "    # Calculate weighted entropy after the split\n",
    "    weighted_entropy = 0\n",
    "    for i, value in enumerate(values):\n",
    "        subset = data[data[feature] == value]\n",
    "        subset_entropy = Entropy(subset)\n",
    "        weighted_entropy += (counts[i] / counts.sum()) * subset_entropy\n",
    "    \n",
    "    # Information gain is the reduction in entropy\n",
    "    info_gain = total_entropy - weighted_entropy\n",
    "    return info_gain\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 3. Count Positive and Negative Examples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "def count_positive_negative(data):\n",
    "    target = data.iloc[:, -1]  # Assuming target is the last column\n",
    "    positive_count = (target == \"Yes\").sum()\n",
    "    negative_count = (target == \"No\").sum()\n",
    "    return positive_count, negative_count\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### DecisionTreeID3 CLASS\n",
    "The decision tree recursively selects the attribute with the highest information gain at each step and continues to split the dataset until a stopping condition is met (e.g., all examples are classified or no attributes are left)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "class DecisionTreeID3:\n",
    "    def __init__(self):\n",
    "        self.tree = {}\n",
    "\n",
    "    def fit(self, data, original_data=None, features=None, parent_node_class=None):\n",
    "        if features is None:\n",
    "            features = data.columns[:-1]  # All features except the target column\n",
    "            \n",
    "        if original_data is None:\n",
    "            original_data = data\n",
    "        \n",
    "        # If all examples have the same label, return this label (leaf node)\n",
    "        if len(np.unique(data.iloc[:, -1])) <= 1:\n",
    "            return np.unique(data.iloc[:, -1])[0]\n",
    "        \n",
    "        # If no more features to split, return the majority class of the parent node\n",
    "        elif len(features) == 0:\n",
    "            return parent_node_class\n",
    "        \n",
    "        # Otherwise, grow the tree\n",
    "        else:\n",
    "            # Count positive and negative examples\n",
    "            positive_count, negative_count = count_positive_negative(data)\n",
    "            \n",
    "            # Select the majority class as the default class\n",
    "            parent_node_class = \"Yes\" if positive_count >= negative_count else \"No\"\n",
    "            \n",
    "            # Calculate the information gain for each feature\n",
    "            gains = {feature: Gain(data, feature) for feature in features}\n",
    "            \n",
    "            # Select the feature with the highest information gain\n",
    "            best_feature = max(gains, key=gains.get)\n",
    "            \n",
    "            # Build the tree\n",
    "            tree = {best_feature: {}}\n",
    "            \n",
    "            # Remove the feature from the list of available features\n",
    "            remaining_features = [feat for feat in features if feat != best_feature]\n",
    "            \n",
    "            # Split the data based on the best feature\n",
    "            for value in np.unique(data[best_feature]):\n",
    "                subset = data[data[best_feature] == value]\n",
    "                \n",
    "                # Recursively build the subtree\n",
    "                subtree = self.fit(subset, original_data, remaining_features, parent_node_class)\n",
    "                \n",
    "                # Assign the subtree to the current tree node\n",
    "                tree[best_feature][value] = subtree\n",
    "            \n",
    "            self.tree = tree\n",
    "            return tree\n",
    "\n",
    "    def predict(self, query):\n",
    "        tree = self.tree\n",
    "        while isinstance(tree, dict):\n",
    "            feature = list(tree.keys())[0]\n",
    "            value = query[feature]\n",
    "            tree = tree[feature].get(value, \"Unknown\")  # Default to \"Unknown\" if the value is not found\n",
    "        return tree\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "import json\n",
    "\n",
    "def print_tree(tree):\n",
    "    # Use json.dumps to format the dictionary with indentation\n",
    "    formatted_tree = json.dumps(tree, indent=4)\n",
    "    # Print the formatted tree with single quotes instead of double quotes\n",
    "    formatted_tree = formatted_tree.replace('\"', \"'\")\n",
    "    print(formatted_tree)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Instantiate and train the ID3 decision tree"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Decision Tree:\n",
      "{\n",
      "    'Outlook': {\n",
      "        'overcast': 'yes',\n",
      "        'rain': {\n",
      "            'Wind': {\n",
      "                'strong': 'no',\n",
      "                'weak': 'yes'\n",
      "            }\n",
      "        },\n",
      "        'sunny': {\n",
      "            'Humidity': {\n",
      "                'high': 'no',\n",
      "                'normal': 'yes'\n",
      "            }\n",
      "        }\n",
      "    }\n",
      "}\n"
     ]
    }
   ],
   "source": [
    "tree = DecisionTreeID3()\n",
    "decision_tree = tree.fit(df)\n",
    "\n",
    "# Example usage of print_tree\n",
    "print(\"Decision Tree:\")\n",
    "print_tree(decision_tree)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Make Prediction on a given SAMPLE"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Prediction for {'Outlook': 'sunny', 'Temperature': 'cool', 'Humidity': 'high', 'Wind': 'strong'}: no\n"
     ]
    }
   ],
   "source": [
    "# Example query to predict the outcome\n",
    "query = {\n",
    "    'Outlook': 'sunny',\n",
    "    'Temperature': 'cool',\n",
    "    'Humidity': 'high',\n",
    "    'Wind': 'strong'\n",
    "}\n",
    "\n",
    "# Make prediction\n",
    "prediction = tree.predict(query)\n",
    "print(f\"Prediction for {query}: {prediction}\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
